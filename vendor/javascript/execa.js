// execa@5.1.1 downloaded from https://ga.jspm.io/npm:execa@5.1.1/index.js

import*as e from"path";import*as t from"child_process";import*as o from"cross-spawn";import*as n from"strip-final-newline";import*as r from"npm-run-path";import*as s from"onetime";import*as i from"human-signals";import*as a from"os";import*as d from"signal-exit";import*as c from"is-stream";import*as l from"get-stream";import*as u from"merge-stream";import f from"process";import m from"buffer";var p="default"in i?i.default:i;var g={};const{signalsByName:v}=p;const getErrorPrefix=({timedOut:e,timeout:t,errorCode:o,signal:n,signalDescription:r,exitCode:s,isCanceled:i})=>e?`timed out after ${t} milliseconds`:i?"was canceled":void 0!==o?`failed with ${o}`:void 0!==n?`was killed with ${n} (${r})`:void 0!==s?`failed with exit code ${s}`:"failed";const makeError$1=({stdout:e,stderr:t,all:o,error:n,signal:r,exitCode:s,command:i,escapedCommand:a,timedOut:d,isCanceled:c,killed:l,parsed:{options:{timeout:u}}})=>{s=null===s?void 0:s;r=null===r?void 0:r;const f=void 0===r?void 0:v[r].description;const m=n&&n.code;const p=getErrorPrefix({timedOut:d,timeout:u,errorCode:m,signal:r,signalDescription:f,exitCode:s,isCanceled:c});const g=`Command ${p}: ${i}`;const y="[object Error]"===Object.prototype.toString.call(n);const w=y?`${g}\n${n.message}`:g;const h=[w,t,e].filter(Boolean).join("\n");if(y){n.originalMessage=n.message;n.message=h}else n=new Error(h);n.shortMessage=w;n.command=i;n.escapedCommand=a;n.exitCode=s;n.signal=r;n.signalDescription=f;n.stdout=e;n.stderr=t;void 0!==o&&(n.all=o);"bufferedData"in n&&delete n.bufferedData;n.failed=true;n.timedOut=Boolean(d);n.isCanceled=c;n.killed=l&&!d;return n};g=makeError$1;var y=g;var w={};const h=["stdin","stdout","stderr"];const hasAlias=e=>h.some((t=>void 0!==e[t]));const normalizeStdio$1=e=>{if(!e)return;const{stdio:t}=e;if(void 0===t)return h.map((t=>e[t]));if(hasAlias(e))throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${h.map((e=>`\`${e}\``)).join(", ")}`);if("string"===typeof t)return t;if(!Array.isArray(t))throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);const o=Math.max(t.length,h.length);return Array.from({length:o},((e,o)=>t[o]))};w=normalizeStdio$1;w.node=e=>{const t=normalizeStdio$1(e);return"ipc"===t?"ipc":void 0===t||"string"===typeof t?[t,t,t,"ipc"]:t.includes("ipc")?t:[...t,"ipc"]};var C=w;var x="default"in a?a.default:a;var b="default"in d?d.default:d;var E={};const T=x;const $=b;const O=5e3;const spawnedKill$1=(e,t="SIGTERM",o={})=>{const n=e(t);setKillTimeout(e,t,o,n);return n};const setKillTimeout=(e,t,o,n)=>{if(!shouldForceKill(t,o,n))return;const r=getForceKillAfterTimeout(o);const s=setTimeout((()=>{e("SIGKILL")}),r);s.unref&&s.unref()};const shouldForceKill=(e,{forceKillAfterTimeout:t},o)=>isSigterm(e)&&false!==t&&o;const isSigterm=e=>e===T.constants.signals.SIGTERM||"string"===typeof e&&"SIGTERM"===e.toUpperCase();const getForceKillAfterTimeout=({forceKillAfterTimeout:e=true})=>{if(true===e)return O;if(!Number.isFinite(e)||e<0)throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e};const spawnedCancel$1=(e,t)=>{const o=e.kill();o&&(t.isCanceled=true)};const timeoutKill=(e,t,o)=>{e.kill(t);o(Object.assign(new Error("Timed out"),{timedOut:true,signal:t}))};const setupTimeout$1=(e,{timeout:t,killSignal:o="SIGTERM"},n)=>{if(0===t||void 0===t)return n;let r;const s=new Promise(((n,s)=>{r=setTimeout((()=>{timeoutKill(e,o,s)}),t)}));const i=n.finally((()=>{clearTimeout(r)}));return Promise.race([s,i])};const validateTimeout$1=({timeout:e})=>{if(void 0!==e&&(!Number.isFinite(e)||e<0))throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)};const setExitHandler$1=async(e,{cleanup:t,detached:o},n)=>{if(!t||o)return n;const r=$((()=>{e.kill()}));return n.finally((()=>{r()}))};E={spawnedKill:spawnedKill$1,spawnedCancel:spawnedCancel$1,setupTimeout:setupTimeout$1,validateTimeout:validateTimeout$1,setExitHandler:setExitHandler$1};var P=E;var k="default"in c?c.default:c;var S="default"in l?l.default:l;var A="default"in u?u.default:u;var j={};const B=k;const I=S;const D=A;const handleInput$1=(e,t)=>{void 0!==t&&void 0!==e.stdin&&(B(t)?t.pipe(e.stdin):e.stdin.end(t))};const makeAllStream$1=(e,{all:t})=>{if(!t||!e.stdout&&!e.stderr)return;const o=D();e.stdout&&o.add(e.stdout);e.stderr&&o.add(e.stderr);return o};const getBufferedData=async(e,t)=>{if(e){e.destroy();try{return await t}catch(e){return e.bufferedData}}};const getStreamPromise=(e,{encoding:t,buffer:o,maxBuffer:n})=>{if(e&&o)return t?I(e,{encoding:t,maxBuffer:n}):I.buffer(e,{maxBuffer:n})};const getSpawnedResult$1=async({stdout:e,stderr:t,all:o},{encoding:n,buffer:r,maxBuffer:s},i)=>{const a=getStreamPromise(e,{encoding:n,buffer:r,maxBuffer:s});const d=getStreamPromise(t,{encoding:n,buffer:r,maxBuffer:s});const c=getStreamPromise(o,{encoding:n,buffer:r,maxBuffer:2*s});try{return await Promise.all([i,a,d,c])}catch(n){return Promise.all([{error:n,signal:n.signal,timedOut:n.timedOut},getBufferedData(e,a),getBufferedData(t,d),getBufferedData(o,c)])}};const validateInputSync$1=({input:e})=>{if(B(e))throw new TypeError("The `input` option cannot be a stream in sync mode")};j={handleInput:handleInput$1,makeAllStream:makeAllStream$1,getSpawnedResult:getSpawnedResult$1,validateInputSync:validateInputSync$1};var R=j;var M={};const K=(async()=>{})().constructor.prototype;const G=["then","catch","finally"].map((e=>[e,Reflect.getOwnPropertyDescriptor(K,e)]));const mergePromise$1=(e,t)=>{for(const[o,n]of G){const r="function"===typeof t?(...e)=>Reflect.apply(n.value,t(),e):n.value.bind(t);Reflect.defineProperty(e,o,{...n,value:r})}return e};const getSpawnedPromise$1=e=>new Promise(((t,o)=>{e.on("exit",((e,o)=>{t({exitCode:e,signal:o})}));e.on("error",(e=>{o(e)}));e.stdin&&e.stdin.on("error",(e=>{o(e)}))}));M={mergePromise:mergePromise$1,getSpawnedPromise:getSpawnedPromise$1};var N=M;var F={};const normalizeArgs=(e,t=[])=>Array.isArray(t)?[e,...t]:[e];const L=/^[\w.-]+$/;const H=/"/g;const escapeArg=e=>"string"!==typeof e||L.test(e)?e:`"${e.replace(H,'\\"')}"`;const joinCommand$1=(e,t)=>normalizeArgs(e,t).join(" ");const getEscapedCommand$1=(e,t)=>normalizeArgs(e,t).map((e=>escapeArg(e))).join(" ");const U=/ +/g;const parseCommand$1=e=>{const t=[];for(const o of e.trim().split(U)){const e=t[t.length-1];e&&e.endsWith("\\")?t[t.length-1]=`${e.slice(0,-1)} ${o}`:t.push(o)}return t};F={joinCommand:joinCommand$1,getEscapedCommand:getEscapedCommand$1,parseCommand:parseCommand$1};var W=F;var _="default"in e?e.default:e;var q="default"in t?t.default:t;var z="default"in o?o.default:o;var J="default"in n?n.default:n;var Q="default"in r?r.default:r;var V="default"in s?s.default:s;var X={};var Y=m.Buffer;var Z=f;const ee=_;const te=q;const oe=z;const ne=J;const re=Q;const se=V;const ie=y;const ae=C;const{spawnedKill:de,spawnedCancel:ce,setupTimeout:le,validateTimeout:ue,setExitHandler:fe}=P;const{handleInput:me,getSpawnedResult:pe,makeAllStream:ge,validateInputSync:ve}=R;const{mergePromise:ye,getSpawnedPromise:we}=N;const{joinCommand:he,parseCommand:Ce,getEscapedCommand:xe}=W;const be=1e8;const getEnv=({env:e,extendEnv:t,preferLocal:o,localDir:n,execPath:r})=>{const s=t?{...Z.env,...e}:e;return o?re.env({env:s,cwd:n,execPath:r}):s};const handleArguments=(e,t,o={})=>{const n=oe._parse(e,t,o);e=n.command;t=n.args;o=n.options;o={maxBuffer:be,buffer:true,stripFinalNewline:true,extendEnv:true,preferLocal:false,localDir:o.cwd||Z.cwd(),execPath:Z.execPath,encoding:"utf8",reject:true,cleanup:true,all:false,windowsHide:true,...o};o.env=getEnv(o);o.stdio=ae(o);"win32"===Z.platform&&"cmd"===ee.basename(e,".exe")&&t.unshift("/q");return{file:e,args:t,options:o,parsed:n}};const handleOutput=(e,t,o)=>"string"===typeof t||Y.isBuffer(t)?e.stripFinalNewline?ne(t):t:void 0===o?void 0:"";const execa=(e,t,o)=>{const n=handleArguments(e,t,o);const r=he(e,t);const s=xe(e,t);ue(n.options);let i;try{i=te.spawn(n.file,n.args,n.options)}catch(e){const t=new te.ChildProcess;const o=Promise.reject(ie({error:e,stdout:"",stderr:"",all:"",command:r,escapedCommand:s,parsed:n,timedOut:false,isCanceled:false,killed:false}));return ye(t,o)}const a=we(i);const d=le(i,n.options,a);const c=fe(i,n.options,d);const l={isCanceled:false};i.kill=de.bind(null,i.kill.bind(i));i.cancel=ce.bind(null,i,l);const handlePromise=async()=>{const[{error:e,exitCode:t,signal:o,timedOut:a},d,u,f]=await pe(i,n.options,c);const m=handleOutput(n.options,d);const p=handleOutput(n.options,u);const g=handleOutput(n.options,f);if(e||0!==t||null!==o){const d=ie({error:e,exitCode:t,signal:o,stdout:m,stderr:p,all:g,command:r,escapedCommand:s,parsed:n,timedOut:a,isCanceled:l.isCanceled,killed:i.killed});if(!n.options.reject)return d;throw d}return{command:r,escapedCommand:s,exitCode:0,stdout:m,stderr:p,all:g,failed:false,timedOut:false,isCanceled:false,killed:false}};const u=se(handlePromise);me(i,n.options.input);i.all=ge(i,n.options);return ye(i,u)};X=execa;X.sync=(e,t,o)=>{const n=handleArguments(e,t,o);const r=he(e,t);const s=xe(e,t);ve(n.options);let i;try{i=te.spawnSync(n.file,n.args,n.options)}catch(e){throw ie({error:e,stdout:"",stderr:"",all:"",command:r,escapedCommand:s,parsed:n,timedOut:false,isCanceled:false,killed:false})}const a=handleOutput(n.options,i.stdout,i.error);const d=handleOutput(n.options,i.stderr,i.error);if(i.error||0!==i.status||null!==i.signal){const e=ie({stdout:a,stderr:d,error:i.error,signal:i.signal,exitCode:i.status,command:r,escapedCommand:s,parsed:n,timedOut:i.error&&"ETIMEDOUT"===i.error.code,isCanceled:false,killed:null!==i.signal});if(!n.options.reject)return e;throw e}return{command:r,escapedCommand:s,exitCode:0,stdout:a,stderr:d,failed:false,timedOut:false,isCanceled:false,killed:false}};X.command=(e,t)=>{const[o,...n]=Ce(e);return execa(o,n,t)};X.commandSync=(e,t)=>{const[o,...n]=Ce(e);return execa.sync(o,n,t)};X.node=(e,t,o={})=>{if(t&&!Array.isArray(t)&&"object"===typeof t){o=t;t=[]}const n=ae.node(o);const r=Z.execArgv.filter((e=>!e.startsWith("--inspect")));const{nodePath:s=Z.execPath,nodeOptions:i=r}=o;return execa(s,[...i,e,...Array.isArray(t)?t:[]],{...o,stdin:void 0,stdout:void 0,stderr:void 0,stdio:n,shell:false})};var Ee=X;const Te=X.sync,$e=X.command,Oe=X.commandSync,Pe=X.node;export default Ee;export{$e as command,Oe as commandSync,Pe as node,Te as sync};

